<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación de Planificación de Colas Multinivel (MLQ)</title>
    <!-- Incluye Tailwind CSS para un diseño moderno y rápido -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para la simulación */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .shadow-custom {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 0 15px rgba(0, 0, 0, 0.05);
        }
        /* Estilos para las colas */
        .queue-container {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            min-height: 150px;
        }
        .queue {
            flex-grow: 1;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            transition: all 0.3s;
        }
        .queue-title {
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        .process-pill {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            margin: 0.25rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            color: white;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: default;
        }
        .process-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        /* Colores de las Colas */
        .queue-0 .queue-title { color: #ef4444; } /* Rojo - RR */
        .queue-1 .queue-title { color: #f97316; } /* Naranja - FCFS */
        .queue-2 .queue-title { color: #22c55e; } /* Verde - FCFS */
        .current-process {
            border: 3px solid #3b82f6;
            box-shadow: 0 0 10px #3b82f6;
            animation: pulse-blue 1s infinite alternate;
        }
        @keyframes pulse-blue {
            from { box-shadow: 0 0 10px #3b82f6; }
            to { box-shadow: 0 0 20px #3b82f6, 0 0 10px #3b82f6; }
        }

        /* Estilos para el Gráfico de Gantt */
        #gantt-container {
            overflow-x: auto;
            white-space: nowrap;
            height: 150px;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background-color: white;
        }
        .gantt-bar-wrapper {
            display: flex;
            height: 100%;
            align-items: flex-end;
        }
        .gantt-block {
            height: 50%; /* Altura de la barra */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem; /* Ajuste para mejor lectura */
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            padding: 0 4px;
            box-sizing: border-box;
        }
        .timeline {
            display: flex;
            position: relative;
            height: 50%;
            border-top: 1px dashed #9ca3af;
        }
        .time-label {
            position: absolute;
            top: 5px;
            font-size: 0.75rem;
            color: #4b5563;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b pb-2">Simulador de Planificación de Colas Multinivel (MLQ)</h1>
        
        <!-- Controles de Configuración -->
        <div id="controls" class="bg-white p-6 rounded-xl shadow-custom mb-6 grid grid-cols-1 md:grid-cols-4 gap-6">
            
            <!-- Columna 1: Añadir Proceso -->
            <div class="space-y-4 col-span-1">
                <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">Añadir Proceso</h2>
                <input id="p-name" type="text" placeholder="Nombre (P1, P2...)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" value="P">
                <input id="p-burst" type="number" placeholder="Tiempo de Ráfaga (Burst)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" min="1" value="10">
                <input id="p-arrival" type="number" placeholder="Tiempo de Llegada (Arrival)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" min="0" value="0">
                <select id="p-queue" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <option value="0">Cola 0 (RR, Alta)</option>
                    <option value="1">Cola 1 (FCFS, Media)</option>
                    <option value="2">Cola 2 (FCFS, Baja)</option>
                </select>
                <button onclick="addProcess()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg transition duration-150">Añadir Proceso</button>
            </div>

            <!-- Columna 2: Procesos Añadidos (Nuevo) -->
            <div class="space-y-4 col-span-2">
                <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">Procesos en Espera (Modificar)</h2>
                <div id="process-list" class="space-y-2 max-h-52 overflow-y-auto p-2 bg-gray-50 rounded-lg border border-gray-200">
                    <!-- Los procesos añadidos se mostrarán aquí -->
                </div>
                <button onclick="clearAllProcesses()" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 rounded-lg transition duration-150 text-sm">Eliminar Todos los Procesos</button>
            </div>

            <!-- Columna 3: Configuración y Control -->
            <div class="space-y-4 col-span-1 flex flex-col justify-between">
                <div>
                    <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">Control de Simulación</h2>
                    <label for="quantum" class="block text-sm font-medium text-gray-700 mt-2">Quantum (para Cola 0 - RR)</label>
                    <input id="quantum" type="number" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" min="1" value="3">
                    <p class="text-sm text-gray-500 mt-2">Tiempo Actual: <span id="current-time" class="font-bold text-lg text-indigo-600">0</span></p>
                </div>
                <div class="flex space-x-3 mt-4">
                    <button id="run-btn" onclick="runSimulation()" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition duration-150 text-lg">
                        <span id="run-text">EJECUTAR</span>
                    </button>
                    <button onclick="resetSimulation()" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 rounded-lg transition duration-150 text-lg">REINICIAR</button>
                </div>
            </div>
        </div>

        <!-- Visualización de Colas -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8">Colas de Procesos (Ready Queues)</h2>
        <div class="queue-container mb-8">
            <div id="queue-0" class="queue queue-0 shadow-custom">
                <div class="queue-title text-red-600">COLA 0 (RR, Prioridad Alta - Interactivos)</div>
                <div id="processes-0"></div>
            </div>
            <div id="queue-1" class="queue queue-1 shadow-custom">
                <div class="queue-title text-orange-600">COLA 1 (FCFS, Prioridad Media - Sistema)</div>
                <div id="processes-1"></div>
            </div>
            <div id="queue-2" class="queue queue-2 shadow-custom">
                <div class="queue-title text-green-600">COLA 2 (FCFS, Prioridad Baja - Lotes)</div>
                <div id="processes-2"></div>
            </div>
        </div>

        <!-- Gráfico de Gantt -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8">Gráfico de Gantt (Uso de CPU)</h2>
        <div id="gantt-container" class="shadow-custom relative">
            <div class="gantt-bar-wrapper"></div>
            <div class="timeline"></div>
        </div>

        <!-- Resultados y Métricas -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8">Resultados de la Simulación</h2>
        <div id="results" class="bg-white p-6 rounded-xl shadow-custom">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Proceso</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cola (Prio)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ráfaga (Burst)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Llegada (Arrival)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Finalización (Completion)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Retorno (Turnaround)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Espera (Waiting)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Restante</th>
                    </tr>
                </thead>
                <tbody id="results-body" class="bg-white divide-y divide-gray-200">
                    <!-- Filas de resultados se insertarán aquí -->
                </tbody>
            </table>
            <div id="averages" class="mt-4 pt-4 border-t border-gray-200 text-lg font-semibold text-gray-800">
                <!-- Promedios se insertarán aquí -->
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACIÓN INICIAL Y ESTADO ---
        let processes = []; // Todos los procesos introducidos
        let runningProcesses = []; // Procesos que han llegado y están esperando/corriendo
        let completedProcesses = [];
        let processIdCounter = 1;
        let currentTime = 0;
        let simulationInterval = null;
        let isRunning = false;
        let quantum = 3; // Quantum para la Cola 0 (RR)
        let timeInQuantum = 0; // Contador de tiempo usado por el proceso actual de RR
        let currentProcess = null; // El proceso que actualmente usa la CPU

        // Colores para los procesos
        const colors = [
            '#ef4444', '#f97316', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#facc15', '#06b6d4',
            '#10b981', '#fb923c', '#d946ef', '#6366f1', '#a855f7', '#64748b'
        ];

        // --- 2. GESTIÓN DE PROCESOS Y COLA ---
        
        /**
         * Clase para representar un Proceso.
         */
        class Process {
            constructor(id, name, burst, arrival, queue) {
                this.id = id;
                this.name = name;
                this.initialBurst = parseInt(burst);
                this.remainingBurst = parseInt(burst);
                this.arrival = parseInt(arrival);
                this.queue = parseInt(queue);
                this.startTime = -1;
                this.completionTime = 0;
                this.color = colors[this.id % colors.length];
                this.firstRun = true; // Flag para saber si se ha ejecutado alguna vez
            }

            get turnaroundTime() {
                if (this.completionTime === 0) return 0;
                // Tiempo de Retorno (TAT) = Tiempo de Finalización - Tiempo de Llegada
                return this.completionTime - this.arrival;
            }

            get waitingTime() {
                if (this.completionTime === 0) return 0;
                // Tiempo de Espera (Waiting Time) = TAT - Ráfaga Inicial
                return this.turnaroundTime - this.initialBurst;
            }
        }

        /**
         * Añade un nuevo proceso a la lista.
         */
        function addProcess() {
            if (isRunning) {
                console.warn("No se pueden añadir procesos mientras la simulación está corriendo.");
                return;
            }

            const nameInput = document.getElementById('p-name');
            const burstInput = document.getElementById('p-burst');
            const arrivalInput = document.getElementById('p-arrival');
            const queueInput = document.getElementById('p-queue');

            // Genera el nombre usando el valor del input y el contador actual
            const baseName = nameInput.value.trim();
            const name = baseName + processIdCounter;
            const burst = parseInt(burstInput.value);
            const arrival = parseInt(arrivalInput.value);
            const queue = parseInt(queueInput.value);

            if (burst <= 0 || arrival < 0 || baseName === '') {
                console.error("Valores de entrada inválidos. Burst debe ser > 0 y Arrival >= 0, y el nombre no puede estar vacío.");
                return;
            }

            const newProcess = new Process(processIdCounter++, name, burst, arrival, queue);
            processes.push(newProcess);

            // Ordena todos los procesos por tiempo de llegada
            processes.sort((a, b) => a.arrival - b.arrival);

            nameInput.value = 'P';
            burstInput.value = '10';
            arrivalInput.value = '0';

            updateUI();
        }

        /**
         * Elimina un proceso por su ID.
         */
        function removeProcess(id) {
            if (isRunning) {
                console.warn("No se puede eliminar un proceso mientras la simulación está corriendo.");
                return;
            }
            // Mantenemos solo los procesos cuyo ID no coincide
            processes = processes.filter(p => p.id !== id);
            
            // Si eliminamos todos los procesos, el contador debe resetearse para que los nuevos empiecen en P1
            if (processes.length === 0) {
                processIdCounter = 1;
            } else {
                 // Si eliminamos, ordenamos por ID para mantener la consistencia en el display
                 processes.sort((a, b) => a.id - b.id);
            }
            updateUI();
        }

        /**
         * Elimina todos los procesos.
         */
        function clearAllProcesses() {
            if (isRunning) {
                console.warn("No se pueden eliminar procesos mientras la simulación está corriendo.");
                return;
            }
            resetSimulation(true); // Usamos el flag 'clearAll'
            updateUI();
        }

        /**
         * Inicializa la simulación y el estado de la UI.
         * @param {boolean} clearOnly Determines if the reset should clear processes (true) or just reset time (false)
         */
        function resetSimulation(clearOnly = false) {
            // Asegura que se detiene la simulación y se restablecen los botones.
            stopSimulation(); 
            
            if (clearOnly) {
                processes = [];
                processIdCounter = 1;
            }

            // Los procesos que no se hayan eliminado vuelven a su estado inicial
            processes.forEach(p => {
                p.remainingBurst = p.initialBurst;
                p.completionTime = 0;
                p.startTime = -1;
                p.firstRun = true;
            });
            
            runningProcesses = [];
            completedProcesses = [];
            currentTime = 0;
            currentProcess = null;
            timeInQuantum = 0;
            document.getElementById('current-time').textContent = 0;
            
            // Restablecer el botón a EJECUTAR y color verde, si hay procesos cargados o si el estado es limpio
            if (processes.length === 0 || completedProcesses.length < processes.length) {
                document.getElementById('run-text').textContent = "EJECUTAR";
                document.getElementById('run-btn').classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'bg-red-600');
                document.getElementById('run-btn').classList.add('bg-green-600', 'hover:bg-green-700');
                document.getElementById('run-btn').disabled = false;
            }
            
            clearGantt();
            updateUI();
        }

        // --- 3. LÓGICA DE PLANIFICACIÓN (EL NÚCLEO MLQ) ---

        /**
         * Selecciona el siguiente proceso a ejecutar basado en MLQ (Prioridad Estricta).
         */
        function getNextProcess() {
            // 1. Procesos que han llegado y están listos
            const arrivedProcesses = runningProcesses.filter(p => p.arrival <= currentTime && p.remainingBurst > 0);

            // 2. Colas por Prioridad
            // Cola 0 (RR): Se ordena por ID para simular un orden de llegada justo dentro de la cola
            // NOTA: runningProcesses ya contiene el orden correcto de RR debido al manejo del Quantum
            const queue0 = arrivedProcesses.filter(p => p.queue === 0); 
            
            // Cola 1 y 2 (FCFS): Se ordenan por Tiempo de Llegada
            const queue1 = arrivedProcesses.filter(p => p.queue === 1).sort((a, b) => a.arrival - b.arrival);
            const queue2 = arrivedProcesses.filter(p => p.queue === 2).sort((a, b) => a.arrival - b.arrival);

            // 3. Aplicar Prioridad Estricta: Se atiende la cola más alta que no esté vacía.
            if (queue0.length > 0) {
                return queue0[0]; // Retorna el primero de RR (que es el que le toca por turno)
            } else if (queue1.length > 0) {
                return queue1[0]; // Retorna el primero de FCFS
            } else if (queue2.length > 0) {
                return queue2[0]; // Retorna el primero de FCFS
            }

            return null; // No hay procesos listos para ejecutar
        }


        /**
         * Lógica principal de un paso de la simulación.
         */
        function simulationStep() {
            // A. Mover procesos a la cola de "listos" cuando llegan
            processes.forEach(p => {
                // Verificar si acaba de llegar (en este currentTime) y no está ya en la cola de listos
                const isReady = p.arrival <= currentTime && p.remainingBurst > 0;
                const notInRunning = !runningProcesses.some(rp => rp.id === p.id);

                if (isReady && notInRunning && !completedProcesses.some(cp => cp.id === p.id)) {
                    // Si el proceso acaba de llegar, lo añadimos a la lista de ejecución.
                    // El orden se mantiene por el orden natural de llegada, el planificador se encarga de la prioridad
                    runningProcesses.push(p); 
                    
                    // Asegurar que RR mantenga el orden por ID para nuevas llegadas en T=0
                    if (p.queue === 0) {
                        runningProcesses.sort((a, b) => a.id - b.id);
                    }
                }
            });

            // B. Seleccionar el siguiente proceso
            const nextProcess = getNextProcess();

            if (nextProcess) {
                // Si hay un proceso listo
                
                if (currentProcess !== nextProcess) {
                    // Cambio de contexto o inicio de ejecución
                    currentProcess = nextProcess;
                    timeInQuantum = 0; // Reiniciar quantum si hay cambio
                }

                // C. Ejecución del Proceso
                if (currentProcess.firstRun) {
                    currentProcess.startTime = currentTime;
                    currentProcess.firstRun = false;
                }

                currentProcess.remainingBurst--;
                
                // D. Manejo específico para Cola 0 (RR)
                if (currentProcess.queue === 0) {
                    timeInQuantum++;
                }

                // E. Dibujar en el Gantt
                drawGanttBlock(currentProcess, currentTime, 1);
                
                // F. Manejo de Fin de Proceso o Fin de Quantum

                const finished = currentProcess.remainingBurst === 0;
                const quantumExpired = currentProcess.queue === 0 && timeInQuantum === quantum;
                
                if (finished) {
                    // Proceso Terminado
                    currentProcess.completionTime = currentTime + 1;
                    completedProcesses.push(currentProcess);
                    // IMPORTANTE: Al terminar, eliminar de la lista de runningProcesses
                    runningProcesses = runningProcesses.filter(p => p.id !== currentProcess.id);
                    currentProcess = null; // Liberar la CPU
                    timeInQuantum = 0;
                    
                } else if (quantumExpired) {
                    // CORRECCIÓN CRÍTICA: Fin de Quantum para Cola 0 (RR)
                    
                    // 1. Encontrar el índice del proceso expropiado
                    const index = runningProcesses.findIndex(p => p.id === currentProcess.id);

                    if (index !== -1) {
                        // 2. Mover el proceso al final de la lista de procesos activos
                        const tempProcess = runningProcesses.splice(index, 1)[0];
                        runningProcesses.push(tempProcess);
                    }
                    
                    currentProcess = null; // Fuerza el cambio de contexto
                    timeInQuantum = 0;
                }
                
            } else if (processes.some(p => p.remainingBurst > 0 || p.arrival > currentTime)) {
                // CPU Inactiva (IDLE) - No hay procesos listos AHORA, pero hay pendientes.
                drawGanttBlock(null, currentTime, 1);
                currentProcess = null;
            } else {
                // Simulación Terminada
                stopSimulation();
                return;
            }

            // G. Avanzar el tiempo
            currentTime++;
            document.getElementById('current-time').textContent = currentTime;
            updateUI();
        }

        // --- 4. CONTROL DE SIMULACIÓN ---

        /**
         * Inicia o Pausa la simulación.
         */
        function runSimulation() {
            if (processes.length === 0) {
                console.log("Por favor, añade al menos un proceso para iniciar la simulación.");
                return;
            }

            if (isRunning) {
                stopSimulation();
            } else {
                quantum = parseInt(document.getElementById('quantum').value);
                if (quantum <= 0 || isNaN(quantum)) {
                    console.error("El Quantum debe ser un número entero positivo.");
                    return;
                }
                isRunning = true;
                document.getElementById('run-text').textContent = "PAUSAR";
                document.getElementById('run-btn').classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-red-600');
                document.getElementById('run-btn').classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                
                // Intervalo de 500ms para visualizar el paso a paso
                simulationInterval = setInterval(simulationStep, 500); 
            }
        }

        /**
         * Detiene la simulación.
         */
        function stopSimulation() {
            clearInterval(simulationInterval);
            isRunning = false;
            
            // Obtener el botón para manipular su estado
            const runBtn = document.getElementById('run-btn');

            if (completedProcesses.length === processes.length && processes.length > 0) {
                // Estado: FINALIZADO
                document.getElementById('run-text').textContent = "TERMINADO";
                runBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'bg-green-600', 'hover:bg-green-700');
                runBtn.classList.add('bg-red-600');
                runBtn.disabled = true; // Desactivar el botón
                updateResults();
            } else if (processes.length > 0) {
                // Estado: PAUSADO (o al inicio de la simulación antes de correr)
                document.getElementById('run-text').textContent = "REANUDAR";
                runBtn.classList.remove('bg-green-600', 'hover:bg-green-700', 'bg-red-600');
                runBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                runBtn.disabled = false; // Asegurar que está habilitado para reanudar
            } else {
                // Estado: INICIAL/REINICIADO sin procesos
                document.getElementById('run-text').textContent = "EJECUTAR";
                runBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'bg-red-600');
                runBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                runBtn.disabled = false; 
            }
        }

        // --- 5. ACTUALIZACIÓN DE INTERFAZ DE USUARIO (UI) ---
        
        /**
         * Actualiza la lista de procesos añadidos en el panel de control.
         */
        function updateAddedProcessList() {
            const listContainer = document.getElementById('process-list');
            listContainer.innerHTML = '';
            
            if (processes.length === 0) {
                listContainer.innerHTML = '<p class="text-gray-400 text-sm italic p-2 text-center">No hay procesos configurados.</p>';
                return;
            }
            
            const queueNames = ['Cola 0 (Alta)', 'Cola 1 (Media)', 'Cola 2 (Baja)'];

            processes.forEach(p => {
                const item = document.createElement('div');
                item.className = 'flex items-center justify-between p-2 bg-white rounded-md border border-gray-100 shadow-sm';
                item.innerHTML = `
                    <div class="text-sm font-medium text-gray-800">
                        <span class="font-extrabold text-blue-600">${p.name}</span>
                        <span class="text-xs text-gray-500 ml-2">B:${p.initialBurst} A:${p.arrival}</span>
                        <span class="text-xs font-semibold ml-2" style="color: ${p.color};">${queueNames[p.queue]}</span>
                    </div>
                    <button onclick="removeProcess(${p.id})" class="ml-2 text-red-500 hover:text-red-700 text-xs font-bold transition duration-150 p-1 rounded-full bg-red-50 hover:bg-red-100" title="Eliminar proceso">
                        <!-- Icono de basura (inline SVG) -->
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.86 12.04A2 2 0 0116.14 21H7.86a2 2 0 01-1.99-1.96L5 7m4 0V4a1 1 0 011-1h4a1 1 0 011 1v3M9 11v6m6-6v6m-3-6v6"></path></svg>
                    </button>
                `;
                listContainer.appendChild(item);
            });
        }
        
        /**
         * Actualiza la vista de las colas de procesos.
         */
        function updateQueues() {
            const queuesHTML = { 0: '', 1: '', 2: '' };
            
            // Re-filtrar para asegurar el orden (RR por ID, FCFS por Arrival)
            const queue0 = runningProcesses.filter(p => p.queue === 0);
            const queue1 = runningProcesses.filter(p => p.queue === 1).sort((a, b) => a.arrival - b.arrival);
            const queue2 = runningProcesses.filter(p => p.queue === 2).sort((a, b) => a.arrival - b.arrival);

            [...queue0, ...queue1, ...queue2].forEach(p => {
                let currentClass = currentProcess && currentProcess.id === p.id ? 'current-process' : '';
                
                queuesHTML[p.queue] += `
                    <span class="process-pill ${currentClass}" style="background-color: ${p.color};">
                        ${p.name} (R: ${p.remainingBurst})
                    </span>`;
            });

            document.getElementById('processes-0').innerHTML = queuesHTML[0] || '<p class="text-gray-400 text-sm italic p-2">Cola vacía</p>';
            document.getElementById('processes-1').innerHTML = queuesHTML[1] || '<p class="text-gray-400 text-sm italic p-2">Cola vacía</p>';
            document.getElementById('processes-2').innerHTML = queuesHTML[2] || '<p class="text-gray-400 text-sm italic p-2">Cola vacía</p>';

            updateResults();
        }

        /**
         * Dibuja un bloque en el Gráfico de Gantt, consolidando si es el mismo proceso.
         */
        function drawGanttBlock(process, startTime, duration) {
            const ganttBarWrapper = document.querySelector('.gantt-bar-wrapper');
            const timeline = document.querySelector('.timeline');
            
            const color = process ? process.color : '#9ca3af'; // Gris para CPU Inactiva (IDLE)
            const name = process ? process.name : 'IDLE';
            const blockId = process ? process.id.toString() : 'IDLE';

            const blockWidth = 40; // 40px por unidad de tiempo
            const lastBlock = ganttBarWrapper.lastChild;

            // --- Lógica de Consolidación ---
            if (lastBlock && lastBlock.dataset.processId === blockId) {
                // Si el último bloque es el mismo proceso (o IDLE), lo extendemos
                const currentWidth = parseFloat(lastBlock.style.width.replace('px', ''));
                lastBlock.style.width = `${currentWidth + blockWidth}px`;
                lastBlock.title = `${name} | T: ${parseFloat(lastBlock.dataset.startTime)} - ${startTime + duration}`;
            } else {
                // Nuevo bloque (Cambio de Contexto)
                const block = document.createElement('div');
                block.className = 'gantt-block';
                block.textContent = name;
                block.style.backgroundColor = color;
                block.style.width = `${blockWidth}px`; 
                block.title = `${name} | T: ${startTime} - ${startTime + duration}`;
                block.dataset.processId = blockId;
                block.dataset.startTime = startTime;

                ganttBarWrapper.appendChild(block);

                // Añadir marca de tiempo
                const timeLabel = document.createElement('span');
                timeLabel.className = 'time-label';
                timeLabel.textContent = startTime;
                // La marca de tiempo se coloca al inicio del bloque que acaba de comenzar
                timeLabel.style.left = `${ganttBarWrapper.scrollWidth - blockWidth}px`; 
                timeline.appendChild(timeLabel);
            }
            // --- Fin de Lógica de Consolidación ---
            
            // Asegurar que el scroll esté al final
            ganttBarWrapper.parentElement.scrollLeft = ganttBarWrapper.scrollWidth;
            
            // Añadir la marca del tiempo final solo si termina la simulación o hay un salto grande
            if (completedProcesses.length === processes.length || (currentTime + 1) % 10 === 0) {
                const finalTimeLabel = document.createElement('span');
                finalTimeLabel.className = 'time-label';
                finalTimeLabel.textContent = currentTime + 1;
                finalTimeLabel.style.left = `${ganttBarWrapper.scrollWidth}px`;
                timeline.appendChild(finalTimeLabel);
            }
        }

        /**
         * Limpia el Gráfico de Gantt.
         */
        function clearGantt() {
            document.querySelector('.gantt-bar-wrapper').innerHTML = '';
            document.querySelector('.timeline').innerHTML = '';
        }
        
        /**
         * Actualiza la tabla de resultados.
         */
        function updateResults() {
            const resultsBody = document.getElementById('results-body');
            const averagesDiv = document.getElementById('averages');
            resultsBody.innerHTML = '';
            
            const allProcesses = [...processes].sort((a, b) => a.id - b.id);
            let totalTurnaround = 0;
            let totalWaitingTime = 0;

            allProcesses.forEach(p => {
                const isCompleted = completedProcesses.includes(p);
                const tat = p.turnaroundTime;
                const wt = p.waitingTime;

                if (isCompleted) {
                    totalTurnaround += tat;
                    totalWaitingTime += wt;
                }

                resultsBody.innerHTML += `
                    <tr class="${isCompleted ? 'bg-green-50' : (p.remainingBurst < p.initialBurst ? 'bg-yellow-50' : 'bg-white')}">
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${p.name}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${p.queue} (${['RR','FCFS','FCFS'][p.queue]})</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${p.initialBurst}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${p.arrival}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold ${isCompleted ? 'text-green-600' : 'text-red-600'}">${isCompleted ? p.completionTime : '--'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${isCompleted ? tat.toFixed(2) : '--'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${isCompleted ? wt.toFixed(2) : '--'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${p.remainingBurst}</td>
                    </tr>
                `;
            });

            // Cálculo de Promedios
            if (completedProcesses.length > 0) {
                const numCompleted = completedProcesses.length;
                const avgTAT = totalTurnaround / numCompleted;
                const avgWT = totalWaitingTime / numCompleted;

                averagesDiv.innerHTML = `
                    <p>Tiempo de Retorno Promedio (TAT): <span class="text-blue-600 font-extrabold">${avgTAT.toFixed(2)}</span></p>
                    <p>Tiempo de Espera Promedio (Waiting Time): <span class="text-blue-600 font-extrabold">${avgWT.toFixed(2)}</span></p>
                `;
            } else {
                 averagesDiv.innerHTML = '<p class="text-gray-500">Resultados disponibles al finalizar la simulación.</p>';
            }
        }


        /**
         * Llama a todas las funciones de actualización de la UI.
         */
        function updateUI() {
            updateQueues();
            updateAddedProcessList(); // Nueva función de actualización
        }

        // --- 6. DATOS DE EJEMPLO (Para demo rápida) ---
        
        function loadDefaultProcesses() {
            // Se usa el Caso 1 del script de demo para precargar
            processes.push(new Process(processIdCounter++, 'P-IntA', 8, 0, 0)); // Cola 0 (RR) - Interactivo (Alta Prio)
            processes.push(new Process(processIdCounter++, 'P-Lote', 20, 0, 2)); // Cola 2 (FCFS) - Lote (Baja Prio)
            processes.push(new Process(processIdCounter++, 'P-IntB', 6, 0, 0)); // Cola 0 (RR)

            processes.sort((a, b) => a.arrival - b.arrival);
            updateUI();
        }

        // Cargar datos por defecto al inicio
        window.onload = loadDefaultProcesses;
    </script>
</body>
</html>
