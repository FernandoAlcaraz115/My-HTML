<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulación de Planificación de Colas Multinivel (MLQ)</title>
    <!-- Incluye Tailwind CSS para un diseño moderno y rápido -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para la simulación */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .shadow-custom {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 0 15px rgba(0, 0, 0, 0.05);
        }
        /* Estilos para las colas */
        .queue-container {
            display: flex;
            flex-direction: row;
            gap: 1rem;
            min-height: 150px;
        }
        .queue {
            flex-grow: 1;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            transition: all 0.3s;
        }
        .queue-title {
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        .process-pill {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            margin: 0.25rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            color: white;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: default;
        }
        .process-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        /* Colores de las Colas */
        .queue-0 .queue-title { color: #ef4444; } /* Rojo - RR */
        .queue-1 .queue-title { color: #f97316; } /* Naranja - FCFS */
        .queue-2 .queue-title { color: #22c55e; } /* Verde - FCFS */
        .current-process {
            border: 3px solid #3b82f6;
            box-shadow: 0 0 10px #3b82f6;
            animation: pulse-blue 1s infinite alternate;
        }
        @keyframes pulse-blue {
            from { box-shadow: 0 0 10px #3b82f6; }
            to { box-shadow: 0 0 20px #3b82f6, 0 0 10px #3b82f6; }
        }

        /* Estilos para el Gráfico de Gantt */
        #gantt-container {
            overflow-x: auto;
            white-space: nowrap;
            height: 150px;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background-color: white;
        }
        .gantt-bar-wrapper {
            display: flex;
            height: 100%;
            align-items: flex-end;
        }
        .gantt-block {
            height: 50%; /* Altura de la barra */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            padding: 0 4px;
            box-sizing: border-box;
        }
        .timeline {
            display: flex;
            position: relative;
            height: 50%;
            border-top: 1px dashed #9ca3af;
        }
        .time-label {
            position: absolute;
            top: 5px;
            font-size: 0.75rem;
            color: #4b5563;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b pb-2">Simulador de Planificación de Colas Multinivel (MLQ)</h1>
        
        <!-- Controles de Configuración -->
        <div id="controls" class="bg-white p-6 rounded-xl shadow-custom mb-6 grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">Añadir Proceso</h2>
                <input id="p-name" type="text" placeholder="Nombre (P1, P2...)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" value="P">
                <input id="p-burst" type="number" placeholder="Tiempo de Ráfaga (Burst)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" min="1" value="10">
                <input id="p-arrival" type="number" placeholder="Tiempo de Llegada (Arrival)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" min="0" value="0">
                <select id="p-queue" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <option value="0">Cola 0 (RR, Alta)</option>
                    <option value="1">Cola 1 (FCFS, Media)</option>
                    <option value="2">Cola 2 (FCFS, Baja)</option>
                </select>
                <button onclick="addProcess()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg transition duration-150">Añadir Proceso</button>
            </div>

            <div class="space-y-4">
                <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">Configuración del Planificador</h2>
                <label for="quantum" class="block text-sm font-medium text-gray-700">Quantum (para Cola 0 - RR)</label>
                <input id="quantum" type="number" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" min="1" value="3">
                <p class="text-sm text-gray-500 mt-2">Cola 0 (Prioridad Alta): Round Robin (RR)</p>
                <p class="text-sm text-gray-500">Cola 1 y 2 (Prioridades Media/Baja): FCFS</p>
                <p class="text-xs text-red-500 mt-4">¡Recuerda! En MLQ, una cola superior siempre interrumpe a una inferior.</p>
            </div>

            <div class="space-y-4 flex flex-col justify-between">
                <div>
                    <h2 class="text-xl font-semibold text-gray-700 border-b pb-2">Control de Simulación</h2>
                    <p class="text-sm text-gray-500 mb-4">Tiempo Actual: <span id="current-time" class="font-bold text-lg text-indigo-600">0</span></p>
                </div>
                <div class="flex space-x-3">
                    <button id="run-btn" onclick="runSimulation()" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition duration-150 text-lg">
                        <span id="run-text">EJECUTAR</span>
                    </button>
                    <button onclick="resetSimulation()" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 rounded-lg transition duration-150 text-lg">REINICIAR</button>
                </div>
            </div>
        </div>

        <!-- Visualización de Colas -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8">Colas de Procesos (Ready Queues)</h2>
        <div class="queue-container mb-8">
            <div id="queue-0" class="queue queue-0 shadow-custom">
                <div class="queue-title text-red-600">COLA 0 (RR, Prioridad Alta - Interactivos)</div>
                <div id="processes-0"></div>
            </div>
            <div id="queue-1" class="queue queue-1 shadow-custom">
                <div class="queue-title text-orange-600">COLA 1 (FCFS, Prioridad Media - Sistema)</div>
                <div id="processes-1"></div>
            </div>
            <div id="queue-2" class="queue queue-2 shadow-custom">
                <div class="queue-title text-green-600">COLA 2 (FCFS, Prioridad Baja - Lotes)</div>
                <div id="processes-2"></div>
            </div>
        </div>

        <!-- Gráfico de Gantt -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8">Gráfico de Gantt (Uso de CPU)</h2>
        <div id="gantt-container" class="shadow-custom relative">
            <div class="gantt-bar-wrapper"></div>
            <div class="timeline"></div>
        </div>

        <!-- Resultados y Métricas -->
        <h2 class="text-2xl font-bold text-gray-800 mb-4 mt-8">Resultados de la Simulación</h2>
        <div id="results" class="bg-white p-6 rounded-xl shadow-custom">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Proceso</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cola (Prio)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ráfaga (Burst)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Llegada (Arrival)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Finalización (Completion)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Retorno (Turnaround)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Espera (Waiting)</th>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">T. Restante</th>
                    </tr>
                </thead>
                <tbody id="results-body" class="bg-white divide-y divide-gray-200">
                    <!-- Filas de resultados se insertarán aquí -->
                </tbody>
            </table>
            <div id="averages" class="mt-4 pt-4 border-t border-gray-200 text-lg font-semibold text-gray-800">
                <!-- Promedios se insertarán aquí -->
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACIÓN INICIAL Y ESTADO ---
        let processes = []; // Todos los procesos introducidos
        let runningProcesses = []; // Procesos que han llegado y están esperando/corriendo
        let completedProcesses = [];
        let processIdCounter = 1;
        let currentTime = 0;
        let simulationInterval = null;
        let isRunning = false;
        let quantum = 3; // Quantum para la Cola 0 (RR)
        let timeInQuantum = 0; // Contador de tiempo usado por el proceso actual de RR
        let currentProcess = null; // El proceso que actualmente usa la CPU

        // Colores para los procesos
        const colors = [
            '#ef4444', '#f97316', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#facc15', '#06b6d4',
            '#10b981', '#fb923c', '#d946ef', '#6366f1', '#a855f7', '#64748b'
        ];

        // --- 2. GESTIÓN DE PROCESOS Y COLA ---

        /**
         * Clase para representar un Proceso.
         */
        class Process {
            constructor(id, name, burst, arrival, queue) {
                this.id = id;
                this.name = name;
                this.initialBurst = parseInt(burst);
                this.remainingBurst = parseInt(burst);
                this.arrival = parseInt(arrival);
                this.queue = parseInt(queue);
                this.startTime = -1;
                this.completionTime = 0;
                this.color = colors[this.id % colors.length];
                this.firstRun = true; // Flag para saber si se ha ejecutado alguna vez
            }

            get turnaroundTime() {
                if (this.completionTime === 0) return 0;
                // Tiempo de Retorno (TAT) = Tiempo de Finalización - Tiempo de Llegada
                return this.completionTime - this.arrival;
            }

            get waitingTime() {
                if (this.completionTime === 0) return 0;
                // Tiempo de Espera (Waiting Time) = TAT - Ráfaga Inicial
                return this.turnaroundTime - this.initialBurst;
            }
        }

        /**
         * Añade un nuevo proceso a la lista.
         */
        function addProcess() {
            const nameInput = document.getElementById('p-name');
            const burstInput = document.getElementById('p-burst');
            const arrivalInput = document.getElementById('p-arrival');
            const queueInput = document.getElementById('p-queue');

            const name = nameInput.value + processIdCounter;
            const burst = parseInt(burstInput.value);
            const arrival = parseInt(arrivalInput.value);
            const queue = parseInt(queueInput.value);

            if (burst <= 0 || arrival < 0 || name.trim() === '') {
                // Usamos un simple mensaje en el console para la demo
                console.error("Valores de entrada inválidos. Burst debe ser > 0 y Arrival >= 0.");
                return;
            }

            const newProcess = new Process(processIdCounter++, name, burst, arrival, queue);
            processes.push(newProcess);

            // Ordena todos los procesos por tiempo de llegada (para la ejecución inicial)
            processes.sort((a, b) => a.arrival - b.arrival);

            nameInput.value = 'P';
            burstInput.value = '10';
            arrivalInput.value = '0';

            updateUI();
        }

        /**
         * Inicializa la simulación y el estado de la UI.
         */
        function resetSimulation() {
            stopSimulation();
            processes = [];
            runningProcesses = [];
            completedProcesses = [];
            processIdCounter = 1;
            currentTime = 0;
            currentProcess = null;
            timeInQuantum = 0;
            document.getElementById('current-time').textContent = 0;
            document.getElementById('run-text').textContent = "EJECUTAR";
            document.getElementById('run-btn').classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'bg-red-600');
            document.getElementById('run-btn').classList.add('bg-green-600', 'hover:bg-green-700');
            document.getElementById('run-btn').disabled = false;
            clearGantt();
            updateUI();
        }

        // --- 3. LÓGICA DE PLANIFICACIÓN (EL NÚCLEO MLQ) ---

        /**
         * Selecciona el siguiente proceso a ejecutar basado en MLQ (Prioridad Estricta).
         */
        function getNextProcess() {
            // 1. Procesos que han llegado y están listos
            const arrivedProcesses = runningProcesses.filter(p => p.arrival <= currentTime && p.remainingBurst > 0);

            // 2. Colas por Prioridad
            // Cola 0 (RR): Se ordena por ID para simular un orden de llegada justo dentro de la cola
            const queue0 = arrivedProcesses.filter(p => p.queue === 0).sort((a, b) => a.id - b.id);
            // Cola 1 y 2 (FCFS): Se ordenan por Tiempo de Llegada
            const queue1 = arrivedProcesses.filter(p => p.queue === 1).sort((a, b) => a.arrival - b.arrival);
            const queue2 = arrivedProcesses.filter(p => p.queue === 2).sort((a, b) => a.arrival - b.arrival);

            // 3. Aplicar Prioridad Estricta: Se atiende la cola más alta que no esté vacía.
            if (queue0.length > 0) {
                return queue0[0]; // Retorna el primero de RR
            } else if (queue1.length > 0) {
                return queue1[0]; // Retorna el primero de FCFS
            } else if (queue2.length > 0) {
                return queue2[0]; // Retorna el primero de FCFS
            }

            return null; // No hay procesos listos para ejecutar
        }


        /**
         * Lógica principal de un paso de la simulación.
         */
        function simulationStep() {
            // A. Mover procesos a la cola de "listos" cuando llegan
            processes.forEach(p => {
                if (p.arrival === currentTime && !runningProcesses.includes(p) && !completedProcesses.includes(p)) {
                    runningProcesses.push(p);
                }
            });

            // B. Seleccionar el siguiente proceso
            const nextProcess = getNextProcess();

            if (nextProcess) {
                // Si hay un proceso listo
                
                if (currentProcess !== nextProcess) {
                    // Cambio de contexto o inicio de ejecución
                    currentProcess = nextProcess;
                    timeInQuantum = 0; // Reiniciar quantum si hay cambio
                }

                // C. Ejecución del Proceso
                if (currentProcess.firstRun) {
                    currentProcess.startTime = currentTime;
                    currentProcess.firstRun = false;
                }

                currentProcess.remainingBurst--;
                
                // D. Manejo específico para Cola 0 (RR)
                if (currentProcess.queue === 0) {
                    timeInQuantum++;
                }

                // E. Dibujar en el Gantt
                drawGanttBlock(currentProcess, currentTime, 1);
                
                // F. Manejo de Fin de Proceso o Fin de Quantum

                const finished = currentProcess.remainingBurst === 0;
                const quantumExpired = currentProcess.queue === 0 && timeInQuantum === quantum;
                
                if (finished) {
                    // Proceso Terminado
                    currentProcess.completionTime = currentTime + 1;
                    completedProcesses.push(currentProcess);
                    runningProcesses = runningProcesses.filter(p => p.id !== currentProcess.id);
                    currentProcess = null; // Liberar la CPU
                    timeInQuantum = 0;
                    
                } else if (quantumExpired) {
                    // Fin de Quantum para Cola 0 (RR)
                    
                    // Mover el proceso al final de la cola (simulado re-encolando)
                    const tempProcess = currentProcess;
                    runningProcesses = runningProcesses.filter(p => p.id !== currentProcess.id);
                    runningProcesses.push(tempProcess);
                    
                    currentProcess = null; // Fuerza el cambio de contexto
                    timeInQuantum = 0;
                }
                
            } else if (processes.some(p => p.remainingBurst > 0 || p.arrival > currentTime)) {
                // CPU Inactiva (IDLE) - No hay procesos listos AHORA, pero hay pendientes.
                drawGanttBlock(null, currentTime, 1);
                currentProcess = null;
            } else {
                // Simulación Terminada
                stopSimulation();
                return;
            }

            // G. Avanzar el tiempo
            currentTime++;
            document.getElementById('current-time').textContent = currentTime;
            updateUI();
        }

        // --- 4. CONTROL DE SIMULACIÓN ---

        /**
         * Inicia o Pausa la simulación.
         */
        function runSimulation() {
            if (processes.length === 0) {
                // Usamos un simple mensaje en el console para la demo
                console.log("Por favor, añade al menos un proceso para iniciar la simulación.");
                return;
            }

            if (isRunning) {
                stopSimulation();
            } else {
                quantum = parseInt(document.getElementById('quantum').value);
                if (quantum <= 0 || isNaN(quantum)) {
                    console.error("El Quantum debe ser un número entero positivo.");
                    return;
                }
                isRunning = true;
                document.getElementById('run-text').textContent = "PAUSAR";
                document.getElementById('run-btn').classList.remove('bg-green-600', 'hover:bg-green-700');
                document.getElementById('run-btn').classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                
                // Intervalo de 500ms para visualizar el paso a paso
                simulationInterval = setInterval(simulationStep, 500); 
            }
        }

        /**
         * Detiene la simulación.
         */
        function stopSimulation() {
            clearInterval(simulationInterval);
            isRunning = false;
            
            if (completedProcesses.length === processes.length && processes.length > 0) {
                // Finalizado
                document.getElementById('run-text').textContent = "TERMINADO";
                document.getElementById('run-btn').classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
                document.getElementById('run-btn').classList.add('bg-red-600');
                document.getElementById('run-btn').disabled = true;
                updateResults();
            } else if (processes.length > 0) {
                // Pausado
                document.getElementById('run-text').textContent = "REANUDAR";
                document.getElementById('run-btn').classList.remove('bg-green-600', 'hover:bg-green-700');
                document.getElementById('run-btn').classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                document.getElementById('run-btn').disabled = false;
            } else {
                // Estado inicial/reiniciado
                document.getElementById('run-text').textContent = "EJECUTAR";
                document.getElementById('run-btn').classList.remove('bg-yellow-600', 'hover:bg-yellow-700', 'bg-red-600');
                document.getElementById('run-btn').classList.add('bg-green-600', 'hover:bg-green-700');
                document.getElementById('run-btn').disabled = false;
            }
        }

        // --- 5. ACTUALIZACIÓN DE INTERFAZ DE USUARIO (UI) ---

        /**
         * Actualiza la vista de las colas de procesos.
         */
        function updateQueues() {
            const queuesHTML = { 0: '', 1: '', 2: '' };
            
            // Re-filtrar para asegurar el orden (RR por ID, FCFS por Arrival)
            const queue0 = runningProcesses.filter(p => p.queue === 0).sort((a, b) => a.id - b.id);
            const queue1 = runningProcesses.filter(p => p.queue === 1).sort((a, b) => a.arrival - b.arrival);
            const queue2 = runningProcesses.filter(p => p.queue === 2).sort((a, b) => a.arrival - b.arrival);

            [...queue0, ...queue1, ...queue2].forEach(p => {
                let currentClass = currentProcess && currentProcess.id === p.id ? 'current-process' : '';
                
                queuesHTML[p.queue] += `
                    <span class="process-pill ${currentClass}" style="background-color: ${p.color};">
                        ${p.name} (R: ${p.remainingBurst})
                    </span>`;
            });

            document.getElementById('processes-0').innerHTML = queuesHTML[0] || '<p class="text-gray-400 text-sm italic p-2">Cola vacía</p>';
            document.getElementById('processes-1').innerHTML = queuesHTML[1] || '<p class="text-gray-400 text-sm italic p-2">Cola vacía</p>';
            document.getElementById('processes-2').innerHTML = queuesHTML[2] || '<p class="text-gray-400 text-sm italic p-2">Cola vacía</p>';

            updateResults();
        }

        /**
         * Dibuja un bloque en el Gráfico de Gantt.
         */
        function drawGanttBlock(process, startTime, duration) {
            const ganttBarWrapper = document.querySelector('.gantt-bar-wrapper');
            const timeline = document.querySelector('.timeline');
            
            const color = process ? process.color : '#9ca3af'; // Gris para CPU Inactiva (IDLE)
            const name = process ? process.name : 'IDLE';

            // Comprobar si el último bloque ya era el mismo proceso (para consolidar)
            const lastBlock = ganttBarWrapper.lastChild;
            const blockWidth = 20; // 20px por unidad de tiempo

            if (lastBlock && lastBlock.dataset.processId === (process ? process.id : 'IDLE')) {
                // Consolidar: aumentar el ancho del bloque anterior
                const currentWidth = parseFloat(lastBlock.style.width.replace('px', ''));
                lastBlock.style.width = `${currentWidth + blockWidth}px`;
                lastBlock.title = `${name} | T: ${parseFloat(lastBlock.dataset.startTime)} - ${startTime + duration}`;
            } else {
                // Nuevo bloque
                const block = document.createElement('div');
                block.className = 'gantt-block';
                block.textContent = name;
                block.style.backgroundColor = color;
                block.style.width = `${blockWidth}px`; 
                block.title = `${name} | T: ${startTime} - ${startTime + duration}`;
                block.dataset.processId = process ? process.id : 'IDLE';
                block.dataset.startTime = startTime;

                ganttBarWrapper.appendChild(block);

                // Añadir marca de tiempo
                const timeLabel = document.createElement('span');
                timeLabel.className = 'time-label';
                timeLabel.textContent = startTime;
                timeLabel.style.left = `${ganttBarWrapper.scrollWidth - blockWidth}px`; // Ajuste al inicio del nuevo bloque
                timeline.appendChild(timeLabel);
            }
            
            // Asegurar que el scroll esté al final
            ganttBarWrapper.parentElement.scrollLeft = ganttBarWrapper.scrollWidth;
            
            // Añadir la marca del tiempo final solo si termina la simulación o hay un salto grande
            if (completedProcesses.length === processes.length || (currentTime + 1) % 10 === 0) {
                const finalTimeLabel = document.createElement('span');
                finalTimeLabel.className = 'time-label';
                finalTimeLabel.textContent = currentTime + 1;
                finalTimeLabel.style.left = `${ganttBarWrapper.scrollWidth}px`;
                timeline.appendChild(finalTimeLabel);
            }
        }

        /**
         * Limpia el Gráfico de Gantt.
         */
        function clearGantt() {
            document.querySelector('.gantt-bar-wrapper').innerHTML = '';
            document.querySelector('.timeline').innerHTML = '';
        }
        
        /**
         * Actualiza la tabla de resultados.
         */
        function updateResults() {
            const resultsBody = document.getElementById('results-body');
            const averagesDiv = document.getElementById('averages');
            resultsBody.innerHTML = '';
            
            const allProcesses = [...processes].sort((a, b) => a.id - b.id);
            let totalTurnaround = 0;
            let totalWaitingTime = 0;

            allProcesses.forEach(p => {
                const isCompleted = completedProcesses.includes(p);
                const tat = p.turnaroundTime;
                const wt = p.waitingTime;

                if (isCompleted) {
                    totalTurnaround += tat;
                    totalWaitingTime += wt;
                }

                resultsBody.innerHTML += `
                    <tr class="${isCompleted ? 'bg-green-50' : (p.remainingBurst < p.initialBurst ? 'bg-yellow-50' : 'bg-red-50')}">
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${p.name}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${p.queue} (${['RR','FCFS','FCFS'][p.queue]})</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${p.initialBurst}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${p.arrival}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold ${isCompleted ? 'text-green-600' : 'text-red-600'}">${isCompleted ? p.completionTime : '--'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${isCompleted ? tat.toFixed(2) : '--'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${isCompleted ? wt.toFixed(2) : '--'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-800">${p.remainingBurst}</td>
                    </tr>
                `;
            });

            // Cálculo de Promedios
            if (completedProcesses.length > 0) {
                const numCompleted = completedProcesses.length;
                const avgTAT = totalTurnaround / numCompleted;
                const avgWT = totalWaitingTime / numCompleted;

                averagesDiv.innerHTML = `
                    <p>Tiempo de Retorno Promedio (TAT): <span class="text-blue-600 font-extrabold">${avgTAT.toFixed(2)}</span></p>
                    <p>Tiempo de Espera Promedio (Waiting Time): <span class="text-blue-600 font-extrabold">${avgWT.toFixed(2)}</span></p>
                `;
            } else {
                 averagesDiv.innerHTML = '<p class="text-gray-500">Resultados disponibles al finalizar la simulación.</p>';
            }
        }


        /**
         * Llama a todas las funciones de actualización de la UI.
         */
        function updateUI() {
            updateQueues();
        }

        // --- 6. DATOS DE EJEMPLO (Para demo rápida) ---
        
        function loadDefaultProcesses() {
            // Ejemplo para mostrar el poder de la prioridad estricta y el RR
            // P-Int (P0) debe correr en RR. P-LoteA (P2) será interrumpido.
            processes.push(new Process(processIdCounter++, 'P-Int', 8, 0, 0)); // Cola 0 (RR) - Interactivo (Alta Prio)
            processes.push(new Process(processIdCounter++, 'P-LoteA', 25, 0, 2)); // Cola 2 (FCFS) - Lote (Baja Prio)
            processes.push(new Process(processIdCounter++, 'P-Med', 10, 1, 1)); // Cola 1 (FCFS) - Medio
            processes.push(new Process(processIdCounter++, 'P-Int2', 6, 2, 0)); // Cola 0 (RR) - Llega tarde, pero tiene alta prioridad

            processes.sort((a, b) => a.arrival - b.arrival);
            updateUI();
        }

        // Cargar datos por defecto al inicio
        window.onload = loadDefaultProcesses;
    </script>
</body>
</html>
